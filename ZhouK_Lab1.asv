function output = ZhouK_Lab1(ary)

arySize = size(ary); % vector containing the size of the input array

% statement to set the output to 0 if the array isn't square
if arySize(1)~=arySize(2);
    output = 0;
else
    % START OF FIRST OUTPUT VALUE

    mostPositive = max(ary) % row vector containing the max value of each column

    mostNegative = min(transpose(ary)); % row vector containing the min value of each row, which is done by transposing the matrix prior to calling min
    % the flip command is used to reverse the order of the vector, then it
    mostNegative = flip(mostNegative)

    firstValue = dot(mostPositive,mostNegative); % the first output value is the dot product of the vectors

    % END OF FIRST OUTPUT VALUE

    %------------------------------------------------------------------------------------

    % START OF SECOND OUTPUT VALUE

    % START OF FIRST VECTOR TO BE DOTTED

    % Largest magnitude term in each column
    [M,I] = max(abs(ary)); % Use this syntax of the max function in order to store the data for the row numbers of the largest magnitudes of each column of the matrix
    largestMag = []; % define an empty column vector
    % iterate for each column of the matrix
    for c=1:arySize(1)
        largestMag = cat(1,largestMag,[ary(I(c),c)]); % concatenate to the bottom of column vector another column vector containing the row index from the variable I, and the column index from the for loop variable
    end

    % Most negative term in each column
    mostNegative = transpose(min(ary)); % first take the min of all elements, then transpose the returned row vector into a column vector

    % Magnitudes of the sort terms
    mostNegative = abs(mostNegative);

    % Concatenate them, with the sort terms first
    catVector = cat(2,mostNegative,largestMag); % concatenate the vectors by appending them as columns, in the correct order

    % Sort descending by the first column
    catVector = sortrows(catVector,'descend'); % call the sortrows command, specifying descending order

    % First vector to be dotted
    firstVec = catVector(:,2)

    % END OF FIRST VECTOR TO BE DOTTED

    % START OF SECOND VECTOR TO BE DOTTED

    % Smallest magnitude term in each row
    [M,I] = min(abs(transpose(ary))); 
    largestMag = []; % define an empty column vector
    % iterate for each column of the matrix
    for c=1:arySize(1)
        largestMag = cat(1,largestMag,[ary(c,I(c))]); % concatenate to the bottom of column vector another column vector containing the column index from the variable I, and the row index from the for loop variable. It
    end    

    % Diagonal term in each row
    diagonalTerms = diag(ary);

    % Magnitudes of the sort terms
    diagonalTerms = abs(diagonalTerms);

    % Concatenate them with the sort terms first
    catVector = cat(2,diagonalTerms,smallestMag); % concatenate the vectors by appending them as columns, in the correct order

    % Sort ascending by the first column
    catVector = sortrows(catVector); % call the sortrows command

    % Second vector to be dotted
    secondVec = catVector(:,2)

    secondValue = dot(firstVec, secondVec); % the second output value is the dot product of the two vectors

    % END OF SECOND VECTOR TO BE DOTTED
    
    % END OF SECOND OUTPUT VALUE

    %------------------------------------------------------------------------------------

    % START OF THIRD OUTPUT VALUE

    thirdValue = 1; % counter variable that assumes that the matrix is positive definite

    index = 1; % initialie the counter variable

    % this while loop will only run when the matrix has not yet found to be not positive definite, or when the current size of the submatrix being checked is less than or equal to the size of the matrix itself
    while (thirdValue || index <= arySize(1))
        subMatrix = ary(1:index,1:index);
        if det(subMatrix) <= 0
            thirdValue = 0; % update the counter if the submatrix is not positive definite
        end
        index = index + 1; % increment the index to check the next submatrix
    end

    % END OF THIRD OUTPUT VALUE

    output = [firstValue; secondValue; thirdValue]; % Combine the output values into a single column vector

end